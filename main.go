// Command cgpgreyrockpaperscissors generates random moves to play CGP Grey's rock, paper, scissors game. Run the
// program to get the list of moves to play. The game can be found here: https://www.youtube.com/watch?v=PmWQmZXYd74
//
// Do not use this program unless you have already played the game legitimately.
//
// More truthfully, this program is intended to make a point about "nothing up my sleeve" seeds used to generate
// cryptographic parameters, such as elliptic curve parameters. The common approach of hashing an English sentence using
// a secure cryptographic hash function to derive parameters does not prevent an adversary from choosing parameters that
// it finds "interesting" (e.g., due to susceptibility to some private attack) if those parameters occur with some
// reasonable probability, like, say, one in a trillion. In reality, the moves generated by this program are not very
// "random" or "uncontrolled" at all. Readers are encouraged to spot the attack in this program.
package main

import (
	"crypto/sha256"
	"fmt"
)

func main() {
	// "Nothing up my sleeve" self-describing seed to produce verifiably random moves with a clearly defined algorithm:
	const seed = "This message is a sha256 function preimage for selecting rock, paper, scissors options in Grey's 1 in a " +
		"million game YouTube experiment! Give this data for the hash function preimage to derive 32 bytes of data. " +
		"To produce the choices, loop through the bytes, skip zero bytes, and evaluate each value modulo 3. " +
		"0 means rock, 1 means paper, and 2 means scissors."

	buf := sha256.Sum256([]byte(seed))

	const maxMoves = 26 // We don't need all 32 moves
	moves := 0

	for i, b := range buf {
		// Skip zero bytes so that there is no bias in the output (85/255 = 1/3 for each possibility)
		if b == 0 {
			continue
		}

		fmt.Printf("% 2d. ", i+1)
		switch b % 3 {
		case 0:
			fmt.Println("Rock")
		case 1:
			fmt.Println("Paper")
		case 2:
			fmt.Println("Scissors")
		}

		moves++
		if moves >= maxMoves {
			break
		}
	}
}
